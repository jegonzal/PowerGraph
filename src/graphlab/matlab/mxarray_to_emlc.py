#!/bin/python
# Reads in the type file generated by emlc and creates an mxArray to emlc types converter
import sys
import fileinput


scalar_types = frozenset(["int8_T", "uint8_T", "int16_T", "uint16_T", "int32_T", \
                    "uint32_T", "int64_T", "uint64_T", "real32_T", "real64_T",\
                    "real_T", "time_T", "boolean_T", "int_T", "uint_T", \
                    "ulong_T", "char_T", "byte_T", "cint8_T", "cuint8_T", \
                    "cint16_T", "cuint16_T", "cint32_T", "cuint32_T", \
                    "cint64_T", "cuint64_T", "creal32_T", "creal64_T"])

def is_scalar(typename):
  return typename in scalar_types
#enddef

def output_parser_header(typesheaders):
  print "#ifndef MXARRAY_TO_EMLC_HPP"
  print "#define MXARRAY_TO_EMLC_HPP"
  print "#include \"array_converters.hpp\""
  for t in typesheaders:
    print "#include \"%s\"" % t
  #endfor
  print "#include \"graphlab/serialization/serialization_includes.hpp\""
  print
  print "template <typename EMXType>"
  print "struct converter {"
  print "  static void clearemx(EMXType &emxdata) { }"
  print "  static void freeemx(EMXType &emxdata) { }"
  print "#ifdef mex_h"
  print "  static bool mxarray2emx(const mxArray* mx, EMXType &emxdata) {"
  print "    return false;"
  print "  }"
  print "  static bool emx2mxarray(EMXType &emxdata, mxArray* &mx) {"
  print "    return false;"
  print "  }"
  print "#endif"
  print "  static void emxcopy(EMXType &dest, const EMXType &src) {"
  print "    assert(false);"
  print "  }"
  print "};"
  print "#include \"struct_array_converters.hpp\""
  print "#include \"scalar_converters.hpp\""
  
def output_parser_footer():
  print "template <typename EMXType>"
  print "void clearemx(EMXType &emxdata) { converter<EMXType>::clearemx(emxdata); }"
  print
  print "template <typename EMXType>"
  print "void freeemx(EMXType &emxdata) {converter<EMXType>::freeemx(emxdata); }"
  print
  print "#ifdef mex_h"
  print "template <typename EMXType>"
  print "bool mxarray2emx(const mxArray* mx, EMXType &emxdata) {"
  print "  return converter<EMXType>::mxarray2emx(mx, emxdata);"
  print "}"
  print
  print "template <typename EMXType>"
  print "bool emx2mxarray(EMXType &emxdata, mxArray* &mx) {"
  print "  return converter<EMXType>::emx2mxarray(emxdata, mx);"
  print "}"
  print "#endif"
  print
  print "template <typename EMXType>"
  print "void emxcopy(EMXType &dest, const EMXType &src) {"
  print "  converter<EMXType>::emxcopy(dest, src);"
  print "}"
  
  print "#endif"
#enddef



# generate the forward and backward parsers for standard emx types
def generate_standard_emxparser(structname, datatype):
  print "template <>"
  print "struct converter<%s> {" % (structname)
  print "  static void clearemx(%s &emxdata) {" % (structname)
  print "    clear_array<%s,%s>(emxdata);" % (datatype, structname)
  print "  }"
  print
  print "  static void freeemx(%s &emxdata) {" % (structname)
  print "    if (!emxdata.canFreeData) return;"
  print "    if (emxdata.data) free(emxdata.data);"
  print "    if (emxdata.size) free(emxdata.size);"
  print "    emxdata.canFreeData = 0;"
  print "  }"
  print "#ifdef mex_h"
  print "  static bool mxarray2emx(const mxArray* mx, %s &emxdata) {" % (structname)
  print "    return read_array<%s,%s>(mx, emxdata);" % (datatype, structname)
  print "  }"
  print
  print "  static bool emx2mxarray(%s &emxdata, mxArray* &mx) {" % (structname)
  print "    return write_array<%s,%s>(emxdata, mx);" % (datatype, structname)
  print "  }"
  print "#endif"
  print 
  print "  static void emxcopy(%s &dest, const %s &src) {" % (structname, structname)
  print "    copy_array<%s,%s>(dest, src);" % (datatype, structname)
  print "  }"
  print "};"
  print
  print "BEGIN_OUT_OF_PLACE_SAVE(arc, %s, emxdata)" % (structname)
  print "  arc << emxdata.allocatedSize;"
  print "  arc << emxdata.numDimensions;"
  print "  serialize(arc, emxdata.size, emxdata.numDimensions * sizeof(int32_T));"
  print "  serialize(arc, emxdata.data, emxdata.allocatedSize * sizeof(%s));" % (datatype)

  print "END_OUT_OF_PLACE_SAVE()"
  print
  print "BEGIN_OUT_OF_PLACE_LOAD(arc, %s, emxdata)" % (structname)
  print "  arc >> emxdata.allocatedSize;"
  print "  arc >> emxdata.numDimensions;"
  print "  emxdata.size = (int32_T*)malloc(sizeof(int32_T) * emxdata.numDimensions);"
  print "  emxdata.data = (%s*)malloc(sizeof(%s) * emxdata.allocatedSize);" % (datatype, datatype)
  print "  deserialize(arc, emxdata.size, emxdata.numDimensions * sizeof(int32_T));"
  print "  deserialize(arc, emxdata.data, emxdata.allocatedSize * sizeof(%s));" % (datatype)
  print "END_OUT_OF_PLACE_LOAD()"
#enddef

# generate the forward and backward parsers for struct emx types
def generate_struct_emxparser(structname, datatype):
  print "template <>"
  print "struct converter<%s> {" % (structname)
  print "  static void clearemx(%s &emxdata) {" % (structname)
  print "    clear_struct_array<%s,%s>(emxdata);" % (datatype, structname)
  print "  }"
  print
  print "  static void freeemx(%s &emxdata) {" % (structname)
  print "    free_struct_array<%s,%s>(emxdata);" % (datatype, structname)
  print "  }"
  print
  print "#ifdef mex_h"
  print "  static bool mxarray2emx(const mxArray* mx, %s &emxdata) {" % (structname)
  print "    return read_struct_array<%s,%s>(mx, emxdata);" % (datatype, structname)
  print "  }"
  print
  print "  static bool emx2mxarray(%s &emxdata, mxArray* &mx) {" % (structname)
  print "    return write_struct_array<%s,%s>(emxdata, mx);" % (datatype, structname)
  print "  }"
  print "#endif"
  print
  print "  static void emxcopy(%s &dest, const %s &src) {" % (structname, structname)
  print "    copy_struct_array<%s,%s>(dest, src);" % (datatype, structname)
  print "  }"
  print "};"

  print "BEGIN_OUT_OF_PLACE_SAVE(arc, %s, emxdata)" % (structname)
  print "  serialize_struct_array<%s,%s>(arc, emxdata);" % (datatype, structname)
  print "END_OUT_OF_PLACE_SAVE()"
  print
  print "BEGIN_OUT_OF_PLACE_LOAD(arc, %s, emxdata)" % (structname)
  print "  deserialize_struct_array<%s,%s>(arc, emxdata);" % (datatype, structname)
  print "END_OUT_OF_PLACE_LOAD()"
  print
#enddef

def generate_emxparser(structname, datatype):
  # if the datatype ends with '_T' it is a standard type
  if (datatype[-2:] == '_T'):
    generate_standard_emxparser(structname, datatype)
  else:
    generate_struct_emxparser(structname, datatype)
  #endif
#enddef


# generate the forward and backward parsers for all other structs
def generate_structparser(structname, parse):
  # output the clearer
  print "template <>"
  print "struct converter<%s> {" % (structname)

  # output the emxarray to mxarray converter
  print "  static void clearemx(%s &emxdata) {" % (structname)
  for decl in parse["decls"]:
      decltype = decl["decltype"]
      declname = decl["declname"]
      if (declname[0] == '*'):
        declname = declname[1:len(declname)]
        print "    emxdata.%s = (%s*)malloc(sizeof(%s));" % (declname, decltype, decltype)
        print "    converter<%s>::clearemx(*(emxdata.%s));" % (decltype, declname)
      else:
        #scalar or single struct
        print "    converter<%s>::clearemx(emxdata.%s);" % (decltype, declname)
      #endif
  #endfor
  print "  }"
  
  # output the freeer
  
  # output the emxarray to mxarray converter
  print "  static void freeemx(%s &emxdata) {" % (structname)
  for decl in parse["decls"]:
      decltype = decl["decltype"]
      declname = decl["declname"]
      if (declname[0] == '*'):
        declname = declname[1:len(declname)]
        print "    if (emxdata.%s != NULL) {" % declname
        print "      converter<%s>::freeemx(*(emxdata.%s));" % (decltype, declname)
        print "      free(emxdata.%s);" % (declname)
        print "      emxdata.%s = NULL;" % (declname)
        print "    }"
      #endif
  #endfor
  print "  }"
  
  print "#ifdef mex_h"
  # output the mxarray to emxarray converter
  print "  static bool mxarray2emx(const mxArray* mx, %s &emxdata) {" % (structname)
  print "    clearemx(emxdata);"
  print "    if (mx == NULL) return false;"
  print "    bool ret = true;"
  for decl in parse["decls"]:
      decltype = decl["decltype"]
      declname = decl["declname"]
      # make sure that this is variable sized or is a scalar
      # i.e. declname has no square brackets
      if (declname.find("[") != -1):
        # fault!!
        sys.stderr.write("field " + declname + " in struct " + structname + " is not variable size\n")
        return 1
      #endif
        

      # check if this is an array
      if (declname[0] == '*'):
        declname = declname[1:len(declname)]
        print "    ret &= converter<%s>::mxarray2emx(struct_has_field(mx, \"%s\"), *(emxdata.%s));" % (decltype, declname, declname)
      elif is_scalar(decltype):
        #scalar!
        print "    if (struct_has_field(mx, \"%s\") != NULL) ";
        print "      emxdata.%s = (%s)mxGetScalar(struct_has_field(mx, \"%s\"));" % (declname, decltype, declname);
      else:
        # single struct!
        print "    ret &= converter<%s>::mxarray2emx(struct_has_field(mx, \"%s\"), emxdata.%s);" % (decltype, declname, declname)
      #endif
  #endfor
  print "    return ret;";
  print "  }"
  print
  
  # output the emxarray to mxarray converter
  print "  static bool emx2mxarray(%s &emxdata, mxArray* &mx) {" % (structname)
  print "    bool ret = true;"
  print "    mwSize dims[1];"
  print "    dims[0] = 1;"
  print "    mx = mxCreateStructArray(1,dims,0,NULL);"
  print "    mxArray* mxarr = NULL;";
  for decl in parse["decls"]:
      decltype = decl["decltype"]
      declname = decl["declname"]
      # check if this is an array
      if (declname[0] == '*'):
        declname = declname[1:len(declname)]
        print "    mxarr = NULL;";
        print "    ret &= converter<%s>::emx2mxarray(*(emxdata.%s), mxarr);" % (decltype, declname)
        print "    mxAddField(mx, \"%s\");" % declname
        print "    mxSetField(mx, 0, \"%s\", mxarr);" % declname
      elif is_scalar(decltype):
        #scalar!
        print "    mxarr = NULL;";
        print "    mxarr = mxCreateDoubleScalar(emxdata.%s);" % (declname)
        print "    mxAddField(mx, \"%s\");" % declname
        print "    mxSetField(mx, 0, \"%s\", mxarr);" % declname
      else:
        # single struct
        print "    mxarr = NULL;";
        print "    ret &= converter<%s>::emx2mxarray(emxdata.%s, mxarr);" % (decltype, declname)
        print "    mxAddField(mx, \"%s\");" % declname
        print "    mxSetField(mx, 0, \"%s\", mxarr);" % declname
      #endif
  #endfor
  print "    return ret;";
  print "  }"
  print "#endif"
  print
  #output the copier
  print "  static void emxcopy(%s &dest, const %s &src) {" % (structname, structname)
  for decl in parse["decls"]:
      decltype = decl["decltype"]
      declname = decl["declname"]
      # check if this is an array
      if (declname[0] == '*'):
        declname = declname[1:len(declname)]
        print "    if (dest.%s == NULL) {" % (declname)
        print "      dest.%s = (%s *)malloc(sizeof(%s));" % (declname,decltype, decltype)
        print "      converter<%s>::clearemx(*(dest.%s));" % (decltype,declname)
        print "    }"
        print "    converter<%s>::emxcopy(*(dest.%s), *(src.%s));" % (decltype, declname,declname)
      elif is_scalar(decltype):
        #scalar!
        print "    dest.%s = src.%s;" % (declname, declname)
      else:
        # single struct
        print "    converter<%s>::emxcopy(dest.%s, src.%s);" % (decltype, declname, declname)
      #endif
  #endfor
  print "  }"
  print "};"
  print
  print "BEGIN_OUT_OF_PLACE_SAVE(arc, %s, emxdata)" % (structname)
  for decl in parse["decls"]:
      decltype = decl["decltype"]
      declname = decl["declname"]
      # check if this is an array
      if (declname[0] == '*'):
        declname = declname[1:len(declname)]
        print "  arc << (emxdata.%s == NULL);" % (declname)
        print "  if (emxdata.%s != NULL) arc << *(emxdata.%s);" % (declname, declname)
      elif is_scalar(decltype):
        #scalar!
        print "  arc << emxdata.%s;" % (declname)
      else:
        # single struct
        print "  arc << emxdata.%s;" % (declname)
      #endif
  #endfor
  print "END_OUT_OF_PLACE_SAVE()"
  print
  print "BEGIN_OUT_OF_PLACE_LOAD(arc, %s, emxdata)" % (structname)
  print "  bool isnull;"
  for decl in parse["decls"]:
      decltype = decl["decltype"]
      declname = decl["declname"]
      # check if this is an array
      if (declname[0] == '*'):
        declname = declname[1:len(declname)]
        print "  arc >> isnull;"
        print "  if (!isnull) {"
        print "    emxdata.%s = (%s*)malloc(sizeof(%s));" % (declname, decltype, decltype)
        print "    arc >> *(emxdata.%s);" % (declname)
        print "  }"
        print "  else {"
        print "    emxdata.%s = NULL;" % (declname)
        print "  }"
      elif is_scalar(decltype):
        #scalar!
        print "  arc >> emxdata.%s;" % (declname)
      else:
        # single struct
        print "  arc >> emxdata.%s;" % (declname)
      #endif
  #endfor
  print "END_OUT_OF_PLACE_LOAD()"
  print

  return 0
#enddef


def generate_parser(p):
  structname = p["structname"]
  # emxArray__common is not used. do nothing
  if (structname == "emxArray__common"):
    return
  #endif
  
  # if it is an emxArray, we need to build a parser for it
  if (structname[0:8] == "emxArray"):
    print "/*****************    emxArray: " , structname, "    ****************/"
    # what is the datatype?
    # search in the declarations for the data type
    datatype = ""
    for j in p["decls"]:
      if (j["declname"] == "*data"):
        datatype = j["decltype"]
        break
      #endif
    #endfor
    generate_emxparser(structname, datatype);
  else:
    print  "/*****************    Struct: ", structname, "    ****************/"
    generate_structparser(structname, p)
  #endif
#enddef



# -------------------   Main --------------------------


_PY3 = sys.version_info[0] > 2

if _PY3:
    from pyparsing_py3 import Word, Literal, alphas, alphanums, OneOrMore, Group
else:
    from pyparsing_py2 import Word, Literal, alphas, alphanums, OneOrMore, Group


# construct the parser
c_typedef = Literal("typedef")
c_struct = Literal("struct")
c_name = Word( alphas+"_*", alphanums+"_[]" )
c_type = Word( alphas+"_", alphanums+"_" )
c_type2 = c_type ^ ("struct" + c_type)
c_openbrace = Literal("{")
c_closebrace = Literal("}")
c_semicolon = Literal(";")

c_declaration = (c_type.setResultsName("decltype") + c_name.setResultsName("declname") + c_semicolon) ^ \
                ("struct" + c_type.setResultsName("decltype") + c_name.setResultsName("declname") + c_semicolon)
c_declarations = OneOrMore(Group(c_declaration)).setResultsName("decls")
c_structdef = c_typedef + c_struct + c_name.setResultsName("structname") + \
           c_openbrace + c_declarations + c_closebrace + c_name + c_semicolon




if (len(sys.argv) < 2):
  print "Usage: mxarray_to_emlc.py [typesfile] > mxarray_to_emlc.hpp"
  quit()
#endif

# read the input file
f = ""
for line in fileinput.input():
  f = f + line + "\n"
#end for
# run the parser
scn = c_structdef.scanString(f)

# output the header
output_parser_header(sys.argv[1:])
# output the body
ret = 0;
for data,dataStart,dataEnd in scn:
  t = generate_parser(data)
  if (t == 1): ret = 1;
#endfor
# output the footer
output_parser_footer()
if (ret != 0):
  sys.exit(ret)
#endif
